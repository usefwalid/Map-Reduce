Ciphertext-Policy Attribute-Based Encryption
John Bethencourt
Carnegie Mellon University
bethenco@cs.cmu.edu

Amit Sahai ∗
UCLA
sahai@cs.ucla.edu

Abstract
In several distributed systems a user should only be
able to access data if a user posses a certain set of credentials or attributes. Currently, the only method for
enforcing such policies is to employ a trusted server to
store the data and mediate access control. However, if
any server storing the data is compromised, then the
confidentiality of the data will be compromised. In this
paper we present a system for realizing complex access
control on encrypted data that we call Ciphertext-Policy
Attribute-Based Encryption. By using our techniques
encrypted data can be kept confidential even if the storage server is untrusted; moreover, our methods are
secure against collusion attacks. Previous AttributeBased Encryption systems used attributes to describe
the encrypted data and built policies into user’s keys;
while in our system attributes are used to describe a
user’s credentials, and a party encrypting data determines a policy for who can decrypt. Thus, our methods are conceptually closer to traditional access control
methods such as Role-Based Access Control (RBAC).
In addition, we provide an implementation of our system and give performance measurements.

1

Introduction

In many situations, when a user encrypts sensitive
data, it is imperative that she establish a specific access control policy on who can decrypt this data. For
example, suppose that the FBI public corruption offices in Knoxville and San Francisco are investigating
an allegation of bribery involving a San Francisco lobbyist and a Tennessee congressman. The head FBI
agent may want to encrypt a sensitive memo so that
only personnel that have certain credentials or at∗ Supported the US Army Research Office under the CyberTA
Grant No. W911NF-06-1-0316.
† Supported by NSF CNS-0524252 and the US Army Research
Office under the CyberTA Grant No. W911NF-06-1-0316.

Brent Waters †
SRI International
bwaters@csl.sri.com

tributes can access it. For instance, the head agent
may specify the following access structure for accessing
this information: ((“Public Corruption Office”
AND (“Knoxville” OR “San Francisco”)) OR
(management-level > 5) OR “Name: Charlie
Eppes”).
By this, the head agent could mean that the memo
should only be seen by agents who work at the public
corruption offices at Knoxville or San Francisco, FBI
officials very high up in the management chain, and a
consultant named Charlie Eppes.
As illustrated by this example, it can be crucial that
the person in possession of the secret data be able to
choose an access policy based on specific knowledge of
the underlying data. Furthermore, this person may
not know the exact identities of all other people who
should be able to access the data, but rather she may
only have a way to describe them in terms of descriptive
attributes or credentials.
Traditionally, this type of expressive access control
is enforced by employing a trusted server to store data
locally. The server is entrusted as a reference monitor
that checks that a user presents proper certification before allowing him to access records or files. However,
services are increasingly storing data in a distributed
fashion across many servers. Replicating data across
several locations has advantages in both performance
and reliability. The drawback of this trend is that it is
increasingly difficult to guarantee the security of data
using traditional methods; when data is stored at several locations, the chances that one of them has been
compromised increases dramatically. For these reasons
we would like to require that sensitive data is stored in
an encrypted form so that it will remain private even
if a server is compromised.
Most existing public key encryption methods allow
a party to encrypt data to a particular user, but are
unable to efficiently handle more expressive types of encrypted access control such as the example illustrated
above.

Our contribution. In this work, we provide the first
construction of a ciphertext-policy attribute-based encryption (CP-ABE) to address this problem, and give
the first construction of such a scheme. In our system,
a user’s private key will be associated with an arbitrary number of attributes expressed as strings. On
the other hand, when a party encrypts a message in our
system, they specify an associated access structure over
attributes. A user will only be able to decrypt a ciphertext if that user’s attributes pass through the ciphertext’s access structure. At a mathematical level, access structures in our system are described by a monotonic “access tree”, where nodes of the access structure are composed of threshold gates and the leaves
describe attributes. We note that AND gates can be
constructed as n-of-n threshold gates and OR gates
as 1-of-n threshold gates. Furthermore, we can handle
more complex access controls such as numeric ranges
by converting them to small access trees (see discussion
in the implementation section for more details).
Our techniques. At a high level, our work is similar to the recent work of Sahai and Waters [24] and
Goyal et al. [15] on key-policy attribute based encryption (KP-ABE), however we require substantially new
techniques. In key-policy attribute based encryption,
ciphertexts are associated with sets of descriptive attributes, and users’ keys are associated with policies
(the reverse of our situation). We stress that in keypolicy ABE, the encryptor exerts no control over who
has access to the data she encrypts, except by her choice
of descriptive attributes for the data. Rather, she must
trust that the key-issuer issues the appropriate keys
to grant or deny access to the appropriate users. In
other words, in [24, 15], the “intelligence” is assumed
to be with the key issuer, and not the encryptor. In our
setting, the encryptor must be able to intelligently decide who should or should not have access to the data
that she encrypts. As such, the techniques of [24, 15]
do not apply to our setting, and we must develop new
techniques.
At a technical level, the main objective that we must
attain is collusion-resistance: If multiple users collude,
they should only be able to decrypt a ciphertext if at
least one of the users could decrypt it on their own. In
particular, referring back to the example from the beginning of this Introduction, suppose that an FBI agent
that works in the terrorism office in San Francisco colludes with a friend who works in the public corruption
office in New York. We do not want these colluders to
be able to decrypt the secret memo by combining their
attributes. This type of security is the sine qua non of
access control in our setting.

In the work of [24, 15], collusion resistance is insured by using a secret-sharing scheme and embedding
independently chosen secret shares into each private
key. Because of the independence of the randomness
used in each invocation of the secret sharing scheme,
collusion-resistance follows. In our scenario, users’ private keys are associated with sets of attributes instead
of access structures over them, and so secret sharing
schemes do not apply.
Instead, we devise a novel private key randomization
technique that uses a new two-level random masking
methodology. This methodology makes use of groups
with efficiently computable bilinear maps, and it is the
key to our security proof, which we give in the generic
bilinear group model [6, 28].
Finally, we provide an implementation of our system
to show that our system performs well in practice. We
provide a description of both our API and the structure
of our implementation. In addition, we provide several
techniques for optimizing decryption performance and
measure our performance features experimentally.
Organization. The remainder of our paper is structured as follows. In Section 2 we discuss related work.
In Section 3 we our definitions and give background
on groups with efficiently computable bilinear maps.
We then give our construction in Section 4. We then
present our implementation and performance measurements in Section 5. Finally, we conclude in Section 6.

2

Related Work

Sahai and Waters [24] introduced attribute-based
encryption (ABE) as a new means for encrypted access control. In an attribute-based encryption system
ciphertexts are not necessarily encrypted to one particular user as in traditional public key cryptography.
Instead both users’ private keys and ciphertexts will be
associated with a set of attributes or a policy over attributes. A user is able to decrypt a ciphertext if there
is a “match” between his private key and the ciphertext. In their original system Sahai and Waters presented a Threshold ABE system in which ciphertexts
were labeled with a set of attributes S and a user’s private key was associated with both a threshold parameter k and another set of attributes S ′ . In order for a
user to decrypt a ciphertext at least k attributes must
overlap between the ciphertext and his private keys.
One of the primary original motivations for this was
to design an error-tolerant (or Fuzzy) identity-based
encryption [27, 7, 12] scheme that could use biometric
identities.

The primary drawback of the Sahai-Waters [24]
threshold ABE system is that the threshold semantics
are not very expressive and therefore are limiting for
designing more general systems. Goyal et al. introduced the idea of a more general key-policy attributebased encryption system. In their construction a ciphertext is associated with a set of attributes and a
user’s key can be associated with any monotonic treeaccess structure. 1 The construction of Goyal et al.
can be viewed as an extension of the Sahai-Waters techniques where instead of embedding a Shamir [26] secret
sharing scheme in the private key, the authority embeds
a more general secret sharing scheme for monotonic access trees. Goyal et. al. also suggested the possibility
of a ciphertext-policy ABE scheme, but did not offer
any constructions.
Pirretti et al. [23] gave an implementation of
the threshold ABE encryption system, demonstrated
different applications of attribute-based encryption
schemes and addressed several practical notions such as
key-revocation. In recent work, Chase [11] gave a construction for a multi-authority attribute-based encryption system, where each authority would administer a
different domain of attributes. The primary challenge
in creating multi-authority ABE is to prevent collusion
attacks between users that obtain key components from
different authorities. While the Chase system used the
threshold ABE system as its underlying ABE system at
each authority, the problem of multi-authority ABE is
in general orthogonal to finding more expressive ABE
systems.
In addition, there is a long history of access control
for data that is mediated by a server. See for example, [18, 14, 30, 20, 16, 22] and the references therein.
We focus on encrypted access control, where data is
protected even if the server storing the data is compromised.
Collusion Resistance and Attribute-Based Encryption The defining property of Attribute-Based
Encryption systems are their resistance to collusion
attacks. This property is critical for building cryptographic access control systems; otherwise, it is impossible to guarantee that a system will exhibit the
desired security properties as there will exist devastating attacks from an attacker that manages to get a hold
of a few private keys. While we might consider ABE
systems with different flavors of expressibility, prior
work [24, 15] made it clear that collusion resistance
is a required property of any ABE system.
Before attribute-based encryption was introduced
1 Goyal et al. show in addition how to construct a key-policy
ABE scheme for any linear secret sharing scheme.

there were other systems that attempted to address
access control of encrypted data [29, 8] by using secret sharing schemes [17, 9, 26, 5, 3] combined with
identity-based encryption; however, these schemes did
not address resistance to collusion attacks. Recently,
Kapadia, Tsang, and Smith [19] gave a cryptographic
access control scheme that employed proxy servers.
Their work explored new methods for employing proxy
servers to hide policies and use non-monontonic access
control for small universes of attributes. We note that
although they called this scheme a form of CP-ABE,
the scheme does not have the property of collusion resistance. As such, we believe that their work should not
be considered in the class of attribute-based encryption
systems due to its lack of security against collusion attacks.

3

Background

We first give formal definitions for the security
of ciphertext policy attribute based encryption (CPABE). Next, we give background information on bilinear maps. Like the work of Goyal et al. [15] we define
an access structure and use it in our security definitions. However, in these definitions the attributes will
describe the users and the access structures will be used
to label different sets of encrypted data.

3.1

Definitions

Definition 1 (Access Structure [1]) Let
{P1 , P2 , . . . , Pn } be a set of parties. A collection
A ⊆ 2{P1 ,P2 ,...,Pn } is monotone if ∀B, C : if B ∈ A and
B ⊆ C then C ∈ A. An access structure (respectively,
monotone access structure) is a collection (respectively, monotone collection) A of non-empty subsets
of {P1 , P2 , . . . , Pn }, i.e., A ⊆ 2{P1 ,P2 ,...,Pn } \{∅}. The
sets in A are called the authorized sets, and the sets
not in A are called the unauthorized sets.
In our context, the role of the parties is taken by
the attributes. Thus, the access structure A will contain the authorized sets of attributes. We restrict our
attention to monotone access structures. However, it
is also possible to (inefficiently) realize general access
structures using our techniques by having the not of an
attribute as a separate attribute altogether. Thus, the
number of attributes in the system will be doubled.
From now on, unless stated otherwise, by an access
structure we mean a monotone access structure.
An ciphertext-policy attribute based encryption
scheme consists of four fundamental algorithms: Setup,
Encrypt, KeyGen, and Decrypt. In addition, we allow
for the option of a fifth algorithm Delegate.

Setup. The setup algorithm takes no input other
than the implicit security parameter. It outputs the
public parameters PK and a master key MK.
Encrypt(PK, M, A). The encryption algorithm
takes as input the public parameters PK, a message
M , and an access structure A over the universe of
attributes. The algorithm will encrypt M and produce
a ciphertext CT such that only a user that possesses a
set of attributes that satisfies the access structure will
be able to decrypt the message. We will assume that
the ciphertext implicitly contains A.
Key Generation(MK, S). The key generation algorithm takes as input the master key MK and a set of
attributes S that describe the key. It outputs a private
key SK.
Decrypt(PK, CT, SK). The decryption algorithm
takes as input the public parameters PK, a ciphertext
CT, which contains an access policy A, and a private
key SK, which is a private key for a set S of attributes.
If the set S of attributes satisfies the access structure
A then the algorithm will decrypt the ciphertext and
return a message M .
Delegate(SK, S̃). The delegate algorithm takes as
input a secret key SK for some set of attributes S and
˜ for the set of
a set S̃ ⊆ S. It output a secret key SK
attributes S̃.
We now describe a security model for ciphertextpolicy ABE schemes. Like identity-based encryption
schemes [27, 7, 12] the security model allows the adversary to query for any private keys that cannot be
used to decrypt the challenge ciphertext. In CP-ABE
the ciphertexts are identified with access structures and
the private keys with attributes. It follows that in our
security definition the adversary will choose to be challenged on an encryption to an access structure A∗ and
can ask for any private key S such that S does not
satisfy S∗ . We now give the formal security game.
Security Model for CP-ABE
Setup. The challenger runs the Setup algorithm and
gives the public parameters, PK to the adversary.
Phase 1. The adversary makes repeated private keys
corresponding to sets of attributes S1 , . . . , Sq1 .
Challenge. The adversary submits two equal length
messages M0 and M1 . In addition the adversary
gives a challenge access structure A∗ such that

none of the sets S1 , . . . , Sq1 from Phase 1 satisfy
the access structure. The challenger flips a random
coin b, and encrypts Mb under A∗ . The ciphertext
CT∗ is given to the adversary.
Phase 2. Phase 1 is repeated with the restriction that
none of sets of attributes Sq1 +1 , . . . , Sq satisfy the
access structure corresponding to the challenge.
Guess. The adversary outputs a guess b′ of b.
The advantage of an adversary A in this game is
defined as Pr[b′ = b] − 12 . We note that the model
can easily be extended to handle chosen-ciphertext attacks by allowing for decryption queries in Phase 1 and
Phase 2.
Definition 2 An ciphertext-policy attribute-based encryption scheme is secure if all polynomial time adversaries have at most a negligible advantage in the above
game.

3.2

Bilinear Maps

We present a few facts related to groups with efficiently computable bilinear maps.
Let G0 and G1 be two multiplicative cyclic groups
of prime order p. Let g be a generator of G0 and e be
a bilinear map, e : G0 × G0 → G1 . The bilinear map e
has the following properties:
1. Bilinearity: for all u, v ∈ G0 and a, b ∈ Zp , we
have e(ua , v b ) = e(u, v)ab .
2. Non-degeneracy: e(g, g) 6= 1.
We say that G0 is a bilinear group if the group operation in G0 and the bilinear map e : G0 × G0 → G1
are both efficiently computable. Notice that the map
e is symmetric since e(g a , g b ) = e(g, g)ab = e(g b , g a ).

4

Our Construction

In this section we provide the construction of our
system. We begin by describing the model of access
trees and attributes for respectively describing ciphertexts and private keys. Next, we give the description
of our scheme. Finally, we follow with a discussion of
security, efficiency, and key revocation. We provide our
proof of security in Appendix A.

4.1

Our Model

In our construction private keys will be identified
with a set S of descriptive attributes. A party that

wishes to encrypt a message will specify through an
access tree structure a policy that private keys must
satisfy in order to decrypt.
Each interior node of the tree is a threshold gate and
the leaves are associated with attributes. (We note
that this setting is very expressive. For example, we
can represent a tree with “AND” and “OR” gates by
using respectively 2 of 2 and 1 of 2 threshold gates.) A
user will be able to decrypt a ciphertext with a given
key if and only if there is an assignment of attributes
from the private key to nodes of the tree such that the
tree is satisfied. We use the same notation as [15] to
describe the access trees, even though in our case the
attributes are used to identify the keys (as opposed to
the data).
Access tree T . Let T be a tree representing an access structure. Each non-leaf node of the tree represents a threshold gate, described by its children and
a threshold value. If numx is the number of children of a node x and kx is its threshold value, then
0 < kx ≤ numx . When kx = 1, the threshold gate is
an OR gate and when kx = numx , it is an AND gate.
Each leaf node x of the tree is described by an attribute
and a threshold value kx = 1.
To facilitate working with the access trees, we define
a few functions. We denote the parent of the node x
in the tree by parent(x). The function att(x) is defined
only if x is a leaf node and denotes the attribute associated with the leaf node x in the tree. The access tree
T also defines an ordering between the children of every node, that is, the children of a node are numbered
from 1 to num. The function index(x) returns such
a number associated with the node x. Where the index values are uniquely assigned to nodes in the access
structure for a given key in an arbitrary manner.

the Lagrange coefficient ∆i,S for
Q i ∈ Zp and a set, S,
of elements in Zp : ∆i,S (x) = j∈S,j6=i x−j
i−j . We will
additionally employ a hash function H : {0, 1}∗ → G0
that we will model as a random oracle. The function
will map any attribute described as a binary string to
a random group element. Our construction follows.
Setup. The setup algorithm will choose a bilinear
group G0 of prime order p with generator g. Next
it will choose two random exponents α, β ∈ Zp . The
public key is published as:
PK = G0 , g, h = g β , f = g 1/β , e(g, g)α
and the master key MK is (β, g α ). (Note that f is used
only for delegation.)
Encrypt(PK, M, T ). The encryption algorithm encrypts a message M under the tree access structure T .
The algorithm first chooses a polynomial qx for each
node x (including the leaves) in the tree T . These
polynomials are chosen in the following way in a topdown manner, starting from the root node R. For each
node x in the tree, set the degree dx of the polynomial
qx to be one less than the threshold value kx of that
node, that is, dx = kx − 1.
Starting with the root node R the algorithm chooses
a random s ∈ Zp and sets qR (0) = s. Then, it chooses
dR other points of the polynomial qR randomly to
define it completely. For any other node x, it sets
qx (0) = qparent(x) (index(x)) and chooses dx other points
randomly to completely define qx .
Let, Y be the set of leaf nodes in T . The ciphertext
is then constructed by giving the tree access structure
T and computing
CT = T , C̃ = M e(g, g)αs , C = hs ,

Satisfying an access tree. Let T be an access tree
with root r. Denote by Tx the subtree of T rooted at
the node x. Hence T is the same as Tr . If a set of
attributes γ satisfies the access tree Tx , we denote it as
Tx (γ) = 1. We compute Tx (γ) recursively as follows.
If x is a non-leaf node, evaluate Tx′ (γ) for all children
x′ of node x. Tx (γ) returns 1 if and only if at least
kx children return 1. If x is a leaf node, then Tx (γ)
returns 1 if and only if att(x) ∈ γ.

4.2

Our Construction

Let G0 be a bilinear group of prime order p, and let
g be a generator of G0 . In addition, let e : G0 × G0 →
G1 denote the bilinear map. A security parameter, κ,
will determine the size of the groups. We also define

∀y ∈ Y :


Cy = g qy (0) , Cy′ = H(att(y))qy (0) .

KeyGen(MK, S). The key generation algorithm
will take as input a set of attributes S and output a
key that identifies with that set. The algorithm first
chooses a random r ∈ Zp , and then random rj ∈ Zp
for each attribute j ∈ S. Then it computes the key as
SK = D = g (α+r)/β ,
∀j ∈ S :


Dj = g r · H(j)rj , Dj′ = g rj .

Delegate(SK, S̃). The delegation algorithm takes in
a secret key SK, which is for a set S of attributes, and
another set S̃ such that S̃ ⊆ S. The secret key is of
the form SK = (D, ∀j ∈ S : Dj , Dj′ ). The algorithm

chooses random r̃ and r̃k ∀k ∈ S̃. Then it creates a new
secret key as
˜ = (D̃ = Df r̃ ,
SK
∀k ∈ S̃ :

D̃k = Dk g r̃ H(k)r̃k , D̃k′ = Dk′ g r̃k ).

˜ is a secret key for the
The resulting secret key SK
set S̃. Since the algorithm re-randomizes the key, a
delegated key is equivalent to one received directly from
the authority.
Decrypt(CT, SK). We specify our decryption procedure as a recursive algorithm. For ease of exposition
we present the simplest form of the decryption algorithm and discuss potential performance improvements
in the next subsection.
We
first
define
a
recursive
algorithm
DecryptNode(CT, SK, x) that takes as input a ciphertext CT = (T , C̃, C, ∀y ∈ Y : Cy , Cy′ ), a private
key SK, which is associated with a set S of attributes,
and a node x from T .
If the node x is a leaf node then we let i = att(x)
and define as follows: If i ∈ S, then
DecryptNode(CT, SK, x) =

e(Di , Cx )
e(Di′ , Cx′ )

e g r · H(i)ri , hqx (0)
=
e(g ri , H(i)qx (0) )



= e(g, g)rqx (0) .
If i ∈
/ S, then we define DecryptNode(CT, SK, x) = ⊥.
We now consider the recursive case when x is a
non-leaf node. The algorithm DecryptNode(CT, SK, x)
then proceeds as follows: For all nodes z that are children of x, it calls DecryptNode(CT, SK, z) and stores
the output as Fz . Let Sx be an arbitrary kx -sized set
of child nodes z such that Fz 6= ⊥. If no such set exists then the node was not satisfied and the function
returns ⊥.
Otherwise, we compute
Fx =

∆i,S ′ (0)

i=index(z)

Y

Fz

Y

(e(g, g)r·qz (0) ) i,Sx

Y

(e(g, g)r·qparent(z) (index(z)) ) i,Sx

Y

r·qx (i)·∆i,S ′ (0)

x

,

where S ′ ={index(z):z∈S }

z∈Sx

=

x

x

∆

′ (0)

Now that we have defined our function
DecryptNode, we can define the decryption algorithm. The algorithm begins by simply calling the
function on the root node R of the tree T . If the tree is
satisfied by S we set A = DecryptNode(CT, SK, r) =
e(g, g)rqR (0) = e(g, g)rs . The algorithm now decrypts
by computing


 
C̃/(e(C, D)/A) = C̃/ e hs , g (α+r)/β /e(g, g)rs = M.

4.3

Discussion

We now provide a brief discussion about the security
intuition for our scheme (a full proof is given in Appendix A), our scheme’s efficiency, and how we might
handle key revocation.
Security intuition. As in previous attribute-based
encryption schemes the main challenge in designing our
scheme was to prevent against attacks from colluding
users. Like the scheme of Sahai and Waters [24] our
solution randomizes users private keys such that they
cannot be combined; however, in our solution the secret
sharing must be embedded into the ciphertext instead
to the private keys. In order to decrypt an attacker
clearly must recover e(g, g)αs . In order to do this the
attacker must pair C from the ciphertext with the D
component from some user’s private key. This will result in the desired value e(g, g)αs , but blinded by some
value e(g, g)rs . This value can be blinded out if and
only if enough the user has the correct key components to satisfy the secret sharing scheme embedded in
the ciphertext. Collusion attacks won’t help since the
blinding value is randomized to the randomness from
a particular user’s private key.
While we described our scheme to be secure against
chosen plaintext attacks, the security of our scheme
can efficiently be extended to chosen ciphertext attacks by applying a random oracle technique such as
that of the the Fujisaki-Okamoto transformation [13].
Alternatively, we can leverage the delegation mechanism of our scheme and apply the Cannetti, Halevi,
and Katz [10] method for achieving CCA-security.

z∈Sx

=

∆

z∈Sx

=

e(g, g)

′ (0)

Efficiency. The efficiencies of the key generation and
(by construction) encryption algorithms are both fairly straightforward.

x

z∈Sx

= e(g, g)r·qx (0)

(using polynomial interpolation)

and return the result.

The encryption algorithm will require two exponentiations for each leaf in the ciphertext’s access tree. The
ciphertext size will include two group elements for each
tree leaf. The key generation algorithm requires two
exponentiations for every attribute given to the user,
and the private key consists of two group elements for

"a : 0***"
"a : *0**"
"a : **0*" "a : ***0"
Figure 1. Policy tree implementing the integer
comparison “a < 11”.

every attribute. In its simplest form, the decryption algorithm could require two pairings for every leaf of the
access tree that is matched by a private key attribute
and (at most2 ) one exponentiation for each node along
a path from such a leaf to the root. However, there
might be several ways to satisfy a policy, so a more
intelligent algorithm might try to optimize along these
lines. In our implementation description in Section 5
we described various performance enhancements.
Key-revocation and numerical attributes. KeyRevocation is typically a difficult issue in identitybased encryption [27, 7] and related schemes. The core
challenge is that since the party encrypting the data
does not obtain the receiver’s certificate on-line, he is
not able to check if the the receiving party is revoked.
In attribute-based encryption the problem is even more
tricky since several different users might match the decryption policy. The usual solution is to append to
each of the identities or descriptive attributes a date
for when the attribute expires. For instance, Pirretti et
al. [23] suggest extending each attribute with an expiration date. For example, instead of using the attribute
“Computer Science” we might use the attribute “Computer Science: Oct 17, 2006”.
This type of method has a several shortcomings.
Since the attributes incorporate an exact date there
must be agreement on this between the party encrypting the data and the key issuing authority. If we wish
for a party to be able to specify policy about revocation
dates on a fine-grained scale, users will be forced to go
often to the authority and maintain a large amount of
private key storage, a key for every time period.
Ideally, we would like an attribute-based encryption
system to allow a key authority to give out a single key
with some expiration date X rather than a separate key
2 Fewer exponentiations may occur if there is an unsatisfied
internal node along the path.

for every time period before X. When a party encrypts
a message on some date Y , a user with a key expiring
on date X should be able to decrypt iff X ≥ Y and
the rest of the policy matches the user’s attributes. In
this manner, different expiration dates can be given to
different users and there does not need to be any close
coordination between the parties encrypting data and
the authority.
This sort of functionality can be realized by extending our attributes to support numerical values and our
policies to support integer comparisons. To represent
a numerical attribute “a = k” for some n-bit integer k
we convert it into a “bag of bits” representation, producing n (non-numerical) attributes which specify the
value of each bit in k. As an example, to give out a private key with the 4-bit attribute “a = 9”, we would instead include “a : 1***”, “a : *0***”, “a : **0*”, and
“a : ***1” in the key. We can then use policies of AND
and OR gates to implement integer comparisons over
such attributes, as shown for “a < 11” in Figure 1.
There is a direct correspondence between the bits of
the constant 11 and the choice of gates. Policies for ≤,
>, ≥, and = can be implemented similarly with at most
n gates, or possibly fewer depending on the constant.
It is also possible to construct comparisons between
two numerical attributes (rather than an attribute and
a constant) using roughly 3n gates, although it is less
clear when this would be useful in practice.

5

Implementation

In this section we discuss practical issues in implementing the construction of Section 4, including several
optimizations, a description of the toolkit we have developed, and measurements of its performance.

5.1

Decryption Efficiency Improvements

While little can be done to reduce the group operations necessary for the setup, key generation, and encryption algorithms, the efficiency of the decryption algorithm can be improved substantially with novel techniques. We explain these improvements here and later
give measurements showing their effects in Section 5.3.
Optimizing the decryption strategy. The recursive algorithm given in Section 4 results in two pairings
for each leaf node that is matched by a private key attribute, and up to one exponentiation for every node
occurring along the path from such a node to the root
(not including the root). The final step after the recursive portion adds an additional pairing. Of course, at
each internal node with threshold k, the results from

all but k of its children are thrown away. By considering ahead of time which leaf nodes are satisfied and
picking a subset of them which results in the satisfaction of the entire access tree, we may avoid evaluating
DecryptNode where the result will not ultimately be
used.
More precisely, let M be a subset of the nodes in an
access tree T . We define restrict(T , M ) to be the access tree formed by removing the following nodes from
T (while leaving the thresholds unmodified). First, we
remove all nodes not in M . Next we remove any node
not connected to the original root of T along with any
internal node x that now has fewer children than its
threshold kx . This is repeated until no further nodes
are removed, and the result is restrict(T , M ). So given
an access tree T and a set of attributes γ that satisfies
it, the natural problem is to pick a set M such that γ
satisfies restrict(T , M ) and the number of leaves in M
is minimized (considering pairing to be the most expensive operation). This is easily accomplished with a
straightforward recursive algorithm that makes a single
traversal of the tree. We may then use DecryptNode
on restrict(T , M ) with the same result.
Direct computation of DecryptNode. Further
improvements may be gained by abandoning the
DecryptNode function and making more direct computations. Intuitively, we imagine flattening out the
tree of recursive calls to DecryptNode, then combining the exponentiations into one per (used) leaf node.
Precisely, let T be an access tree with root r, γ be a
set of attributes, and M ⊆ T be such that γ satisfies restrict(T , M ). Assume also that M is minimized
so that no internal node has more children than its
threshold. Let L ⊆ M be the leaf nodes in M . Then
for each ℓ ∈ L, we denote the path from ℓ to r as
ρ(ℓ) = (ℓ, parent(ℓ), parent(parent(ℓ)), . . . r) .
Also, denote the set of siblings of a node x (including
itself) as sibs(x) = { y | parent(x) = parent(y) }. Given
this notation, we may proceed to directly compute the
result of
DecryptNode(CT, SK, r). First, for each ℓ ∈ L, compute zℓ as follows.
Y
i=index(x)
zℓ =
∆i,S (0)
where S={ index(y)
| y ∈ sibs(x) }
x∈ρ(ℓ)
x6=r

Then
DecryptNode(CT, SK, r) =

Y  e(Di , Cℓ ) zℓ
.
e(Di′ , Cℓ′ )

ℓ∈L
i=att(ℓ)

Using this method, the number of exponentiations in
the entire decryption algorithm is reduced from |M |−1
(i.e., one for every node but the root) to |L|. The
number of pairings is 2|L|.
Merging pairings. Still further reductions (this
time in the number of pairings) are possible by combining leaves using the same attribute. If att(ℓ1 ) =
att(ℓ2 ) = i for some ℓ1 , ℓ2 in L, then
e(Di , Cℓ1 )
e(Di′ , Cℓ′ 1 )

!z ℓ

zℓ

=

=

e(Di , Cℓ1 1 )
′ zℓ

e(Di′ , Cℓ1 1 )

1

·

e(Di , Cℓ2 )
e(Di′ , Cℓ′ 2 )

!z ℓ

2

zℓ

·

e(Di , Cℓ2 2 )
′ zℓ

e(Di′ , Cℓ2 2 )

zℓ

zℓ

′ zℓ

′ zℓ

e(Di , Cℓ1 1 · Cℓ2 2 )
e(Di′ , Cℓ1 1 · Cℓ2 2 )

.

Using this fact, we may combine all the pairings for
each distinct attribute in L, reducing the total pairings
to 2m, where m is the number of distinct attributes
appearing in L. Note, however, that the number of
exponentiations increases, and some of the exponentiations must now be performed in G0 rather than G1 .
Specifically, if m′ is the number of leaves sharing their
attribute with at least one other leaf, we must perform
2m′ exponentiations in G0 and |L| − m′ in G1 , rather
than zero and |L| respectively. If exponentiations in G0
(an elliptic curve group) are slower than in G1 (a finite
field of the same order), this technique has the potential to increase decryption time. We further investigate
this tradeoff in Section 5.3.

5.2

The cpabe Toolkit

We have implemented the construction of Section 4
as a convenient set of tools we call the cpabe package [4], which has been made available on the web
under the GPL. The implementation uses the Pairing
Based Cryptography (PBC) library [21].3 The interface of the toolkit is designed for straightforward invocation by larger systems in addition to manual usage.
It provides four command line tools.
cpabe-setup
Generates a public key and a master key.
cpabe-keygen
Given a master key, generates a private key for a
set of attributes, compiling numerical attributes
as necessary.
3 PBC is in turn based on the GNU Multiple Precision arithmetic library (GMP), a high performance arbitrary precision
arithmetic implementation suitable for cryptography.

$ cpabe-keygen -o sara priv key pub key master key \
sysadmin it department 'office = 1431' 'hire date = '`date +%s`
$ cpabe-keygen -o kevin priv key pub key master key \
business staff strategy team 'executive level = 7' \
'office = 2362' 'hire date = '`date +%s`
$ cpabe-enc pub key security report.pdf
(sysadmin and (hire date < 946702800 or security team)) or
(business staff and 2 of (executive level >= 5, audit group, strategy team))

Figure 2. Example usage of the cpabe toolkit. Two private keys are issued for various
sets of attributes (normal and numerical) using cpabe-keygen. A document is encrypted
under a complex policy using cpabe-enc.

cpabe-enc
Given a public key, encrypts a file under an access
tree specified in a policy language.
cpabe-dec
Given a private key, decrypts a file.
The cpabe toolkit supports the numerical attributes
and range queries described in Section 4.3 and provides
a familiar language of expressions with which to specify
access policies. These features are illustrated in the
sample usage session of Figure 2.
In this example, the cpabe-keygen tool was first
used to produce private keys for two new employees,
“Sara” and “Kevin”. A mix of regular and numerical attributes were specified; in particular shell backticks were used to store the current timestamp (in seconds since 1970) in the “hire date” attribute. The
cpabe-enc tool was then used to encrypt a security
sensitive report under a complex policy (in this case
specified on the standard input). The policy allows decryption by sysadmins with at least a certain seniority
(hired before January 1, 2000) and those on the security team. Members of the business staff may decrypt
if they are in the audit group and the strategy team,
or if they are in one of those teams and are an executive of “level” five or more. So in this example, Kevin
would be able to use the key stored as kevin priv key
to decrypt the resulting document, but Sara would not
be able to use hers to decrypt the document.
As demonstrated by this example, the policy language allows the general threshold gates of the underlying scheme, but also provides AND and OR gates for
convenience. These are appropriately merged to simplify the tree, that is, specifying the policy “(a and
b) and (c and d and e)” would result in a single gate.
The tools also handle compiling numerical attributes

to their “bag of bits” representation and comparisons
into their gate-level implementation.

5.3

Performance Measurements

We now provide some information on the performance achieved by the cpabe toolkit. Figure 3 displays
measurements of private key generation time, encryption time, and decryption time produced by running
cpabe-keygen, cpabe-enc, and cpabe-dec on a range
of problem sizes. The measurements were taken on
a modern workstation.4 The implementation uses a
160-bit elliptic curve group based on the supersingular
curve y 2 = x3 +x over a 512-bit finite field. On the test
machine, the PBC library can compute pairings in approximately 5.5ms, and exponentiations in G0 and G1
take about 6.4ms and 0.6ms respectively. Randomly
selecting elements (by reading from the Linux kernel’s
/dev/urandom) is also a significant operation, requiring
about 16ms for G0 and 1.6ms for G1 .
As expected, cpabe-keygen runs in time precisely
linear in the number of attributes associated with the
key it is issuing. The running time of cpabe-enc is also
almost perfectly linear with respect to the number of
leaf nodes in the access policy. The polynomial operations at internal nodes amount to a modest number of
multiplications and do not significantly contribute to
the running time. Both remain quite feasible for even
the largest problem instances.
The performance of cpabe-dec is somewhat more
interesting. It is slightly more difficult to measure in
the absence of a precise application, since the decryption time can depend significantly on the particular
access trees and set of attributes involved. In an at4 The workstation’s processor is a 64-bit, 3.2 Ghz Pentium 4.

3
naive
flatten
merge

1.5

1

0.5

0

time to decrypt (seconds)

0.14
time to encrypt (seconds)

time to generate private key (seconds)

2

2.5
2
1.5
1
0.5
0

0

10
20
30
40
attributes in private key

(a) Key generation time.

50

0.12
0.1
0.08
0.06
0.04
0.02
0

0

20
40
60
80
leaf nodes in policy

(b) Encryption time.

100

0

20
40
60
80
leaf nodes in policy

100

(c) Decryption time with various levels of
optimization.

Figure 3. Performance of the cpabe toolkit.
tempt to average over this variation, we ran cpabe-dec
on a series of ciphertexts that had been encrypted under randomly generated policy trees of various sizes.
The trees were generated by starting with only a root
node, then repeatedly adding a child to a randomly
selected node until the desired number of leaf nodes
was reached. At that point random thresholds were selected for each internal node. Since the time to decrypt
also depends on the particular attributes available, for
each run of cpabe-dec, we selected a key uniformly at
random from all keys satisfying the policy. This was
accomplished by iteratively taking random subsets of
the attributes appearing in leaves of the tree and discarding those that did not satisfy it. A series of runs
of cpabe-dec conducted in this manner produced the
running times displayed in Figure 3 (c).
These measurements give some insight into the effects of the optimizations described in Section 5.1 (all
of which are implemented in the system). The line
marked “naive” denotes the decryption time resulting from running the recursive DecryptNode algorithm
and arbitrarily selecting nodes to satisfy each threshold
gate. By ensuring that the final number of leaf nodes
is minimized when making these decisions and replacing the DecryptNode algorithm with the “flattened”
algorithm to reduce exponentiations, we obtain the improved times denoted “flatten”. Perhaps most interestingly, employing the technique for merging pairings
between leaf nodes sharing the same attribute, denoted
“merge”, actually increases running time in this case,
due to fact that exponentiations are more expensive in
G0 than in G1 .
In summary, cpabe-keygen and cpabe-enc run in
a predictable amount of time based on the number of

attributes in a key or leaves in a policy tree. The performance of cpabe-dec depends on the specific access
tree of the ciphertext and the attributes available in
the private key, and can be improved by some of the
optimizations considered in Section 5.1. In all cases,
the toolkit consumes almost no overhead beyond the
cost of the underlying group operations and random
selection of elements. Large private keys and policies
are possible in practice while maintaining reasonable
running times.

6

Conclusions and Open Directions

We created a system for Ciphertext-Policy Attribute
Based Encryption. Our system allows for a new type of
encrypted access control where user’s private keys are
specified by a set of attributes and a party encrypting
data can specify a policy over these attributes specifying which users are able to decrypt. Our system allows
policies to be expressed as any monotonic tree access
structure and is resistant to collusion attacks in which
an attacker might obtain multiple private keys. Finally,
we provided an implementation of our system, which
included several optimization techniques.
In the future, it would be interesting to consider attribute-based encryption systems with different
types of expressibility. While, Key-Policy ABE and
Ciphertext-Policy ABE capture two interesting and
complimentary types of systems there certainly exist
other types of systems. The primary challenge in this
line of work is to find a new systems with elegant forms
of expression that produce more than an arbitrary combination of techniques.

One limitation of our system is that it is proved secure under the generic group heuristic. We believe an
important endeavor would be to prove a system secure
under a more standard and non-interactive assumption. This type of work would be interesting even if
it resulted in a moderate loss of efficiency from our
existing system.

References
[1] A. Beimel. Secure Schemes for Secret Sharing and Key
Distribution. PhD thesis, Israel Institute of Technology, Technion, Haifa, Israel, 1996.
[2] M. Bellare and P. Rogaway. Random oracles are practical: A paradigm for designing efficient protocols. In
ACM conference on Computer and Communications
Security (ACM CCS), pages 62–73, 1993.
[3] J. Benaloh and L. J. Generalized Secret Sharing
and Monotone Functions. In Advances in Cryptology – CRYPTO, volume 403 of LNCS, pages 27–36.
Springer, 1988.
[4] J. Bethencourt, A. Sahai, and B. Waters. The cpabe
toolkit. http://acsc.csl.sri.com/cpabe/.
[5] G. R. Blakley. Safeguarding cryptographic keys. In
National Computer Conference, pages 313–317. American Federation of Information Processing Societies
Proceedings, 1979.
[6] D. Boneh, X. Boyen, and E.-J. Goh. Hierarchical identity based encryption with constant size ciphertext.
In R. Cramer, editor, EUROCRYPT, volume 3494 of
Lecture Notes in Computer Science, pages 440–456.
Springer, 2005.
[7] D. Boneh and M. Franklin. Identity Based Encryption from the Weil Pairing. In Advances in Cryptology
– CRYPTO, volume 2139 of LNCS, pages 213–229.
Springer, 2001.
[8] R. W. Bradshaw, J. E. Holt, and K. E. Seamons. Concealing complex policies with hidden credentials. In
ACM Conference on Computer and Communications
Security, pages 146–157, 2004.
[9] E. F. Brickell. Some ideal secret sharing schemes.
Journal of Combinatorial Mathematics and Combinatorial Computing, 6:105–113, 1989.
[10] R. Canetti, S. Halevi, and J. Katz. Chosen Ciphertext Security from Identity Based Encryption. In
Advances in Cryptology – Eurocrypt, volume 3027 of
LNCS, pages 207–222. Springer, 2004.
[11] M. Chase. Multi-authority attribute-based encryption. In (To Appear) The Fourth Theory of Cryptography Conference (TCC 2007), 2007.
[12] C. Cocks. An identity based encryption scheme based
on quadratic residues. In IMA Int. Conf., pages 360–
363, 2001.
[13] E. Fujisaki and T. Okamoto. Secure integration of
asymmetric and symmetric encryption schemes. In
CRYPTO, pages 537–554, 1999.

[14] R. Gavriloaie, W. Nejdl, D. Olmedilla, K. E. Seamons,
and M. Winslett. No registration needed: How to use
declarative policies and negotiation to access sensitive
resources on the semantic web. In ESWS, pages 342–
356, 2004.
[15] V. Goyal, O. Pandey, A. Sahai, and B. Waters. Attribute Based Encryption for Fine-Grained Access
Conrol of Encrypted Data. In ACM conference on
Computer and Communications Security (ACM CCS),
2006.
[16] H. Harney, A. Colgrove, and P. D. McDaniel. Principles of policy in secure groups. In NDSS, 2001.
[17] M. Ito, A. Saito, and T. Nishizeki. Secret Sharing
Scheme Realizing General Access Structure. In IEEE
Globecom. IEEE, 1987.
[18] M. H. Kang, J. S. Park, and J. N. Froscher. Access control mechanisms for inter-organizational workflow. In
SACMAT ’01: Proceedings of the sixth ACM symposium on Access control models and technologies, pages
66–74, New York, NY, USA, 2001. ACM Press.
[19] A. Kapadia, P. Tsang, and S. Smith. Attribute-based
publishing with hidden credentials and hidden policies.
In NDSS, 2007.
[20] J. Li, N. Li, and W. H. Winsborough. Automated
trust negotiation using cryptographic credentials. In
ACM Conference on Computer and Communications
Security, pages 46–57, 2005.
[21] B. Lynn. The Pairing-Based Cryptography (PBC) library.
http://crypto.stanford.edu/pbc.
[22] P. D. McDaniel and A. Prakash. Methods and limitations of security policy reconciliation. In IEEE Symposium on Security and Privacy, pages 73–87, 2002.
[23] M. Pirretti, P. Traynor, P. McDaniel, and B. Waters. Secure Atrribute-Based Systems. In ACM conference on Computer and Communications Security
(ACM CCS), 2006.
[24] A. Sahai and B. Waters. Fuzzy Identity Based Encryption. In Advances in Cryptology – Eurocrypt, volume
3494 of LNCS, pages 457–473. Springer, 2005.
[25] J. T. Schwartz. Fast probabilistic algorithms for verification of polynomial identities. J. ACM, 27(4):701–
717, 1980.
[26] A. Shamir. How to share a secret. Commun. ACM,
22(11):612–613, 1979.
[27] A. Shamir. Identity Based Cryptosystems and Signature Schemes. In Advances in Cryptology – CRYPTO,
volume 196 of LNCS, pages 37–53. Springer, 1984.
[28] V. Shoup. Lower bounds for discrete logarithms and
related problems. In EUROCRYPT, pages 256–266,
1997.
[29] N. P. Smart. Access control using pairing based cryptography. In CT-RSA, pages 111–121, 2003.
[30] T. Yu and M. Winslett. A unified scheme for resource
protection in automated trust negotiation. In IEEE
Symposium on Security and Privacy, pages 110–122,
2003.

[31] R. Zippel. Probabilistic algorithms for sparse polynomials. In E. W. Ng, editor, EUROSAM, volume 72
of Lecture Notes in Computer Science, pages 216–226.
Springer, 1979.

A

Security Proof

In this section, we use the generic bilinear group
model of [6, 28] and the random oracle model [2] to
argue that no efficient adversary that acts generically
on the groups underlying our scheme can break the security of our scheme with any reasonable probability.
At an intuitive level, this means that if there are any
vulnerabilities in our scheme, then these vulnerabilities
must exploit specific mathematical properties of elliptic curve groups or cryptographic hash functions used
when instantiating our construction.
While from a security standpoint, it would be preferable to have a proof of security that reduces the
problem of breaking our scheme to a well-studied
complexity-theoretic problem, there is reason to believe
that such reductions will only exist for more complex
(and less efficient) schemes than the one we give here.
We also stress that ours is the first construction which
offers the security properties we are proposing here; we
strongly encourage further research that can place this
kind of security on a firmer theoretical foundation.
The generic bilinear group model. We follow [6]
here: We consider two random encodings ψ0 , ψ1 of the
additive group Fp , that is injective maps ψ0 , ψ1 : Fp →
{0, 1}m , where m > 3 log(p). For i = 0, 1 we write Gi =
{ψi (x) : x ∈ Fp }. We are given oracles to compute
the induced group action on G0 , G1 and an oracle to
compute a non-degenerate bilinear map e : G0 × G0 →
G1 . We are also given a random oracle to represent the
hash function H. We refer to G0 as a generic bilinear
group.
The following theorem gives a lower bound on the
advantage of a generic adversary in breaking our CPABE scheme.
Theorem 1 Let ψ0 , ψ1 , G0 , G1 be defined as above.
For any adversary A, let q be a bound on the total number of group elements it receives from queries it makes
to the oracles for the hash function, groups G0 and G1 ,
and the bilinear map e, and from its interaction with
the CP-ABE security game. Then we have that the advantage of the adversary in the CP-ABE security game
is O(q 2 /p).
Proof. We first make the following standard observation, which follows from a straightforward hybrid argument: In the CP-ABE security game, the challenge
ciphertext has a component C̃ which is randomly either
M0 e(g, g)αs or M1 e(g, g)αs . We can instead consider a
modified game in which C̃ is either e(g, g)αs or e(g, g)θ ,
where θ is selected uniformly at random from Fp , and

the adversary must decide which is the case. It is clear
that any adversary that has advantage ǫ in the CPABE game can be transformed into an adversary that
has advantage at least ǫ/2 in the modified CP-ABE
game. (To see this consider two hybrids: one in which
the adversary must distinguish between M0 e(g, g)αs
and e(g, g)θ ; another in which it must distinguish between e(g, g)θ and M1 e(g, g)αs . Clearly both of these
are equivalent to the modified game above.) From now
on, we will bound the adversary’s advantage in the
modified game.
We now introduce some notation for the simulation
of the modified CP-ABE game. Let g = ψ0 (1) (we will
write g x to denote ψ0 (x), and e(g, g)y to denote ψ1 (y)
in the future).
At setup time, the simulation chooses α, β at random from Fp (which we associate with the integers from
0 to p − 1). Note that if β = 0, an event that happens
with probability 1/p, then setup is aborted, just as it
would be in the actual scheme. The public parameters h = g β , f = g 1/β , and e(g, g)α are sent to the
adversary.
When the adversary (or simulation) calls for the
evaluation of H on any string i, a new random value
ti is chosen from Fp (unless it has already been chosen), and the simulation provides g ti as the response
to H(i).
When the adversary makes its j’th key generation
query for the set Sj of attributes, a new random value
r(j) is chosen from Fp , and for every i ∈ Sj , new ran(j)
dom values ri are chosen from Fp . The simulator
(j)
then computes: D = g (α+r )/β and for each i ∈ Sj ,
(j)
(j)
(j)
we have Di = g r +ti ri and Di′ = g ri . These values
are passed onto the adversary.
When the adversary asks for a challenge, giving two
messages M0 , M1 ∈ G1 , and the access tree A, the simulator does the following. First, it chooses a random s
from Fp . Then it uses the linear secret sharing scheme
associated with A (as described in Section 4) to construct shares λi of s for all relevant attributes i. We
stress again that the λi are all chosen uniformly and
independently at random from Fp subject to the linear conditions imposed on them by the secret sharing
scheme. In particular, the choice of the λi ’s can be perfectly simulated by choosing ℓ random values µ1 , . . . µℓ
uniformly and independently from Fp , for some value
of ℓ, and then letting the λi be fixed public linear combinations of the µk ’s and s. We will often think of
the λi as written as such linear combinations of these
independent random variables later.
Finally, the simulation chooses a random θ ∈ Fp ,
and constructs the encryption as follows: C̃ = e(g, g)θ

and C = hs . For each relevant attribute i, we have
Ci = g λi , and Ci′ = g ti λi . These values are sent to the
adversary.
(Note, of course, that if the adversary asks for a decryption key for a set of attributes that pass the challenge access structure, then the simulation does not
issue the key; similarly if the adversary asks for a challenge access structure such that one of the keys already
issued pass the access structure, then the simulation
aborts and outputs a random guess on behalf of the
adversary, just as it would in the real game.)
We will show that with probability 1 − O(q 2 /p),
taken over the randomness of the the choice of variable
values in the simulation, the adversary’s view in this
simulation is identically distributed to what its view
would have been if it had been given C̃ = e(g, g)αs .
We will therefore conclude that the advantage of the
adversary is at most O(q 2 /p), as claimed.
When the adversary makes a query to the group oracles, we may condition on the event that (1) the adversary only provides as input values it received from the
simulation, or intermediate values it already obtained
from the oracles, and (2) there are p distinct values in
the ranges of both φ0 and φ1 . (This event happens with
overwhelming probability 1−O(1/p).) As such, we may
keep track of the algebraic expressions being called for
from the oracles, as long as no “unexpected collisions”
happen. More precisely, we think of an oracle query
as being a rational function ν = η/ξ in the variables
(j)
θ, α, β, ti ’s, r(j) ’s, ri ’s, s, and µk ’s. An unexpected
collision would be when two queries corresponding to
two distinct formal rational functions η/ξ 6= η ′ /ξ ′ but
where due to the random choices of these variables’ values, we have that the values of η/ξ and η ′ /ξ ′ coincide.
We now condition on the event that no such unexpected collisions occur in either group G0 or G1 . For
any pair of queries (within a group) corresponding to
distinct rational functions η/ξ and η ′ /ξ ′ , a collision occurs only if the non-zero polynomial ηξ ′ − ξη ′ evaluates
to zero. Note that the total degree of ηξ ′ − ξη ′ is in our
case at most 5. By the Schwartz-Zippel lemma [25, 31],
the probability of this event is O(1/p). By a union
bound, the probability that any such collision happens
is at most O(q 2 /p). Thus, we can condition on no such
collision happening and still maintain 1 − O(q 2 /p) of
the probability mass.
Now we consider what the adversary’s view would
have been if we had set θ = αs. We will show that
subject to the conditioning above, the adversary’s view
would have been identically distributed. Since we are
in the generic group model where each group element’s
representation is uniformly and independently chosen,
the only way that the adversary’s view can differ in the

ti ti′
(j)
ti ri′
λi λi′
λi
ti λ i
(j) (j ′ )
ri ri′

λi ti′
ti
ti λi λi′
ti ti′ λi λi′
(j ′ )
(j)
(r(j) + ti ri )(r(j) + ti′ ri′ )
(j)
ri

ti ti′ λi′
α + r(j)
(j)
λi′ r(j) + λi′ ti ri
(j)
(j)
ti λi ri + ti ti′ λi ri′
′
(j)
(j
)
(r(j) + ti ri )ri′
s

(j)

ti r(j) + ti ti′ ri′
αs + sr(j)
(j)
λi ri
(j)
ti λi ri′
(j)
r(j) + ti ri

Table 1. Possible query types from the adversary.

linearP
combinations in order to cancel the terms of the
case of θ = αs is if there are two queries ν and ν ′ into
form j∈T γj sr(j) .
G1 such that ν 6= ν ′ but ν|θ=αs = ν ′ |θ=αs . We will
We observe (by referencing the table above) that
show that this never happens. Suppose not.
θ
the
only other term that the adversary has access to
Recall that since θ only occurs as e(g, g) , which
that could involve monomials of the form sr(j) are oblives in G1 , the only dependence that ν or ν ′ can have
(j)
tained by pairing r(j) + ti ri with some λi′ , since the
on θ is by having some additive terms of the form γ ′ θ,
λi′ terms are linear combinations of s and the µk ’s.
where γ ′ is a constant. Therefore, we must have that
In this way, for sets Tj′ and constants γ(i,j,i′ ) 6= 0,
ν − ν ′ = γαs − γθ, for some constant γ 6= 0. We can
the adversary can construct a query polynomial of the
then artificially add the query ν − ν ′ + γθ = γαs to
form:
the adversary’s queries. But we will now show that the


adversary can never construct a query for e(g, g)γαs


X
X
(subject to the conditioning we have already made),
(j)
γj sr(j) +
γαs+
γ(i,j,i′ ) λi′ r(j) + λi′ ti ri +other terms
which will reach a contradiction and establish the thej∈T
(i,i′ )∈Tj′
orem.
What is left now is to do a case analysis based on
Now, to conclude this proof, we do the following case
the information given to the adversary by the simulaanalysis:
tion. For sake of completeness and ease of reference for
the reader, in Table 1 we enumerate over all rational Case 1 There exists some j ∈ T such that the set of secret
shares Lj = {λi′ : ∃i : (i, i′ ) ∈ Tj′ } do not allow for
function queries possible into G1 by means of the bilinthe reconstruction of the secret s.
ear map and the group elements given the adversary in
the simulation, except those in which every monomial
If this is true, then the term sr(j) will not be
involves the variable β, since β will not be relevant to
canceled, and so the adversary’s query polynomial
constructing a query involving αs. Here the variables i
cannot be of the form γαs.
and i′ are possible attribute strings, and the variables
j and j ′ are the indices of secret key queries made by Case 2 For all j ∈ T the set of secret shares Lj = {λi′ :
∃i : (i, i′ ) ∈ Tj′ } do allow for the reconstruction of
the adversary. These are given in terms of λi ’s, not
the secret s.
µk ’s. The reader may check the values given in Table 1
against the values given in the simulation above.
Fix any j ∈ T . Consider Sj , the set of attributes
In the group G1 , in addition to the polynomials in
belonging to the j’th adversary key request. By
the table above, the adversary also has access to 1 and
the assumption that no requested key should pass
α. The adversary can query for arbitrary linear combithe challenge access structure, and the properties
nations of these, and we must show that none of these
of the secret sharing scheme, we know that the set
polynomials can be equal to a polynomial of the form
L′j = {λi : i ∈ Sj } cannot allow for the reconstrucγαs. Recall that γ 6= 0 is a constant.
tion of s.
As seen above, the only way that the adversary
Thus, there must exist at least one share λi′ in Lj
can create a term containing αs is by pairing sβ with
such that λi′ is linearly independent of L′j when
(j)
(j)
(α + r )/β to get the term αs + sr . In this way,
written in terms of s and the µk ’s. By the case
the adversary
a query polynomial containP could create
analysis, this means that in the adversary’s query
(j)
ing γαs + j∈T γj sr , for some set T and constants
(j)
there is a term of the form λi′ ti ri for some i ∈ Sj .
γ, γj 6= 0.
In order for the adversary to obtain a query polyHowever, (examining the table above), there is no
nomial of the form γαs, the adversary must add other
term that the adversary has access to that can

cancel this term. Therefore, any adversary query
polynomial of this form cannot be of the form γαs.


